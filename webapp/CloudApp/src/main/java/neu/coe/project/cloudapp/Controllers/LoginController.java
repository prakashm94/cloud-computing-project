package neu.coe.project.cloudapp.Controllers;


import neu.coe.project.cloudapp.Model.UserData;
import neu.coe.project.cloudapp.Repository.UserDataRepository;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import java.nio.charset.StandardCharsets;
import java.text.SimpleDateFormat;
import java.util.Base64;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;


import static org.springframework.web.bind.annotation.RequestMethod.POST;

@Controller
@RequestMapping
public class LoginController {
    private static int workload = 17;


    public String[] retrieveParameters(String authorization) {
        String[] values = {};
        if (authorization != null && authorization.toLowerCase().startsWith("basic")) {
            // Authorization: Basic base64credentials
            String base64Credentials = authorization.substring("Basic".length()).trim();
            byte[] credDecoded = Base64.getDecoder().decode(base64Credentials);
            String credentials = new String(credDecoded, StandardCharsets.UTF_8);
            values = credentials.split(":", 2);
        }
        return values;
    }


    @RequestMapping("/time")
    public @ResponseBody String time(@RequestHeader HttpHeaders httpRequest) {

        final String authorization = httpRequest.getFirst("Authorization");
        String[] values = retrieveParameters(authorization);
        Map<String,String> map= new HashMap<String,String>();
        String username = values[0];
        String password = values[1];

        if (Authenticate(username, password)) {

            SimpleDateFormat ft = new SimpleDateFormat("E yyyy.MM.dd 'at' hh:mm:ss a zzz");
            map.put("time", ft.format(new Date()));
            map.put("message", "Login Successful");

            return new JSONObject(map).toString();

        } else {
            map.put("message", "Login Unsuccessful. Please Check username and password");

            return new JSONObject(map).toString();

            //return "You are not logged in. Please check your username and password again";
        }

    }

    public boolean Authenticate(String username, String password) {
        Iterable<UserData> list = userDataRepository.findAll();

        for (UserData u : list) {

            if (u.getUsername().equalsIgnoreCase(username) && checkPassword(password, u.getPassword())) {
                return true;
            }
        }
        return false;
    }

    public boolean findUsername(String username) {
        Iterable<UserData> list = userDataRepository.findAll();
        for (UserData u : list) {
            if (u.getUsername().equalsIgnoreCase(username)) {
                return true;
            }
        }
        return false;
    }

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private UserDataRepository userDataRepository;

    @RequestMapping(method = POST, path = "/user/register") // Map ONLY GET Requests
    public @ResponseBody
    String addNewUser(@RequestHeader HttpHeaders httpRequest) {
        final String authorization = httpRequest.getFirst("Authorization");

        String[] values = retrieveParameters(authorization);
        String username = values[0];
        String password = values[1];
        Map<String,String> map= new HashMap<String,String>();

        if (findUsername(username) == false) {

            String hashedPassword = hashPassword(password);
            UserData n = new UserData();
            n.setUsername(username);
            n.setPassword(hashedPassword);
            userDataRepository.save(n);
            map.put("message", "User "+username+" created successfully");
            return new JSONObject(map).toString();
        } else {
             map.put("message", "Username already exists");
            return new JSONObject(map).toString();
        }
    }

    @GetMapping(path = "/user/all")
    public @ResponseBody
    Iterable<UserData> getAllUsers() {
        // This returns a JSON or XML with the users
        return userDataRepository.findAll();
    }

    public String hashPassword(String password_plaintext) {
        String salt = BCrypt.gensalt(workload);
        String hashed_password = BCrypt.hashpw(password_plaintext, salt);
        return (hashed_password);
    }

    public boolean checkPassword(String password_plaintext, String stored_hash) {
        boolean password_verified = false;
        if (null == stored_hash || !stored_hash.startsWith("$2a$"))
            throw new java.lang.IllegalArgumentException("Invalid hash provided for comparison");

        password_verified = BCrypt.checkpw(password_plaintext, stored_hash);

        return (password_verified);
    }

}
